<?php

/**
 * Implementation of hook_help().
 */
function webfm_attachment_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Addon module to webfm module to enable node attachments');
  }
}

/**
 * Implementation of hook_settings().
 */
function webfm_attachment_settings() {

  $form['webfm_attach_body'] =
    array('#type' => 'checkbox',
          '#title' => t('Append file links to Node Body'),
          '#default_value' => variable_get('webfm_attach_body', ''),
          '#description' => t('Check this box to append downloadable attachments to the node body.
                               <br />This setting does not affect the attachment block.')
          );

  return $form;
}

/**
 * Implementation of hook_perm().
 */
function webfm_attachment_perm() {
  return array('attach WebFM files', 'see webfm_attachments');
}

/**
 * Implementation of hook_block().
 */
function webfm_attachment_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Webfm File Attachments');
    return $blocks;
  }
  else if ($op == 'view' &&
           user_access('access content') &&
           user_access('see webfm_attachments')) {
    $block['content'] = webfm_attach_box();
    $block['subject'] = t('Attachments');
    return $block;
  }
}

function webfm_attach_box() {
  if (arg(0) == 'node' && is_numeric(arg(1)) && !arg(2)) {
    $node = node_load(arg(1));
  }
  $files = webfm_get_attachments($node->nid);
  return theme('webfm_attachments', $files);
}

/**
 * Implementation of hook_menu
 */
function webfm_attachment_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'title' => t('webfm_attach'),
      'path' => 'webfm_attachment',
      'access' => user_access('access webfm'),
      'callback' => 'webfm_attachment_main',
      'type' => MENU_CALLBACK);
    $items[] = array(
      'title' => t('webfm upload'),
      'path' => 'webfm_attach/upload',
      'access' => user_access('access webfm'),
      'callback' => 'webfm_attach_upload',
      'type' => MENU_CALLBACK);
   }
  return $items;
}

function webfm_attach_upload () {

  //get the contents of the form
  $edit = $_POST['edit'];
  $root_path = variable_get('file_directory_path', '').variable_get('webfm_root_dir', '');

  //get the destination path from the edit-webfmuploadpath hidden field in the upload form
  if($edit['webfmuploadpath']) {
    // Check that webfm root is at start of destination path
    if($dest = wfm_check_path(trim($edit['webfmuploadpath']), $root_path)) {
      // Save new file uploads to tmp dir.
      $file = file_check_upload();
      if (($file !== false) && ($file !== 0)) {
        if(webfm_upload_validate($file) === TRUE) {
          // file has been put in temp and we have a valid file object
          if($file_uploaded = file_move($file, $dest)) {
            // file was moved to its final destination
            if($file_in_db = webfm_dbinsert_file($file, $dest)) {
              drupal_set_message('Upload success');
            } else {
              file_delete($file->filepath);
              drupal_set_message('webfm_dbinsert_file() failed', error);
            }
          } else {
            drupal_set_message(t('file_move to %path failed', array('%path' => $dest)), error);
          }
        } else {
          drupal_set_message('webfm_upload_validate() failed', error);
        }
      } else {
        drupal_set_message('file_check_upload() failed', error);
      }
    } else{
      drupal_set_message(t('Invalid destination path: %dest', array('%dest' => $dest)), error);
    }
  } else {
    drupal_set_message(t('Invalid upload path'), error);
  }

  $form = webfm_attachment_upload_form($node);
  $form = form_builder('upload_js', $form);
  $output = theme('status_messages') . form_render($form);
  // We send the updated file attachments form.
  print drupal_to_js(array('status' => TRUE, 'data' => $output));
  exit();
}


function webfm_attachment_main() {

  if(isset($_GET["action"]) && isset($_GET["param"])) {
    switch(trim(strtolower($_GET["action"]))) {

      // AJAX: Get attached items
      case "attach":
        // TO DO: improve this method of getting the node number
        $node_str = trim(strtolower($_GET["param"]));
        // the 'node' var passed via AJAX is the action attribute of id=node-form
        if (($node_num = strstr($node_str, '/node/')) !== FALSE) {
          $node_arr = explode("/", $node_num);
          print drupal_to_js(array('status' => TRUE, 'attach' => webfm_get_attachments($node_arr[2])));
        } else {
          print drupal_to_js(array('status' => FALSE));
        }
        exit();
        break;

      case "attachfile":
        $fid = $_GET["param"];
        $query = "SELECT * FROM {webfm_file} where fid = '%s'";
        if($_file = db_fetch_object(db_query($query, $fid))) {
          $file = new fdesc($_file);
          print drupal_to_js(array('status' => TRUE, 'attach' => $file));
        } else {
          print drupal_to_js(array('status' => FALSE));
        }
        exit();
        break;

      default:
        exit();
        break;
    }
    exit();
  }
  exit();
}

function webfm_get_attachments($nid) {
  $files = array();
  $file_result = db_query('SELECT * FROM {webfm_file} f INNER JOIN {webfm_attach} a ON f.fid = a.fid WHERE a.nid = %d ORDER BY a.weight', $nid);
  while($file_record = db_fetch_object($file_result)) {
    $_file = new fdesc($file_record);
    if($_file->result == TRUE) {
//      drupal_set_message(printf('$_file= %s', print_r($_file)));
      $files[] = $_file;
    }
  }
  return $files;
}

// File description class
// TO DO:  remove spurious record if anything fails!
class fdesc {
  var $result;

  // Constructor:
  function fdesc($file) {
    $cwd = getcwd();
    $this->result = FALSE;
    $dir = dirname($file->fpath);
    //assume the object $file record path has a directory before the file name
    if (is_dir($dir)) {
      if(chdir($dir)) {
        if($handle = opendir('.')) {
          while(($readdir = readdir($handle)) !== false) {
            if(is_dir($readdir))
              continue;

            if(is_file($readdir) && ($readdir == basename($file->fpath))) {
              $this->id = $file->fid;
              $this->n = $file->fname;
              $this->p = $dir;
              $this->e = $file->fmime;
              $this->s = $file->fsize;

              $this->uid = $file->uid;
/* rename fields for expected js variables
              $this->fid = $file->fid;
              $this->fpath = $file->fpath;
              $this->fname = $file->fname;
              $this->fsize = $file->fsize;
              $this->fmime = $file->fmime;
*/
              $this->ftitle = $file->ftitle;
              $this->fdesc = $file->fdesc;
              $this->fcreatedate = $file->fcreatedate;
              $this->flang = $file->flang;
              $this->fpublisher = $file->fpublisher;
              $this->fformat = $file->fformat;
              $this->fversion = $file->fversion;


              $this->m = (filemtime($readdir)) ? date('Y-m-d H:i:s',  @filemtime($readdir)) : "";

              if($i = @getimagesize($readdir)) {
                $this->w = (int) $i[0];
                $this->h = (int) $i[1];
                $this->i = $i[2];
                if(($i[0] == 0) || ($i[1] == 0))
                  $this->i = 0;
              } else
                $this->i = 0;

              $this->result = TRUE;
              break;
            }
          }
          closedir($handle);
        }
        // Restore current working directory
        chdir($cwd);
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function webfm_attachment_nodeapi(&$node, $op, $teaser) {
  switch ($op) {
    case 'load':
      if ((variable_get("wfm_attach_$node->type", 1) == 1) &&
          user_access('see webfm_attachments')) {
        $output['webfm_files'] = webfm_get_attachments($node->nid);
      }
      return $output;
      break;

    case 'view':
      if (is_array($node->webfm_files) && variable_get('webfm_attach_body', '')) {
        // Add the attachments list to node body
        if (count($node->webfm_files) && !$teaser) {
          $node->body .= theme('webfm_attachments', $node->webfm_files);
        }
      }
      break;

    case 'insert':
      $edit = (object)$_POST['edit'];
      if($edit->attachlist) {
        $files = explode(',',$edit->attachlist);
        $i = 0;
        foreach($files as $fid) {
          if($fid)
            // weight argument determined by position in csv
            webfm_dbinsert_attach($node->nid, $fid, $i++);
        }
      }
      break;

    case 'update':
      $edit = (object)$_POST['edit'];
      $files = explode(',',$edit->attachlist);
      webfm_dbupdate_attach($node->nid, $files);
      break;
  }
}

/**
 * Displays file attachments in table
 */
function theme_webfm_attachments($files) {
  global $base_url;
  $header = array(t('Attachment'), t('Size'));
  $rows = array();
  foreach ($files as $file) {
    // 0 =inline : 1 = attach
    $icon_path = $base_url.'/'.variable_get('webfm_icon_dir', 'modules/webfm/image/icon').'/f.gif';
    $href = array('data' => l('<img src="'.$icon_path.'" alt="[file]" />&nbsp;', 'webfm_send/'.$file->id.'/1', '', '' , '' , '', TRUE).l(check_plain($file->ftitle ? $file->ftitle : $file->n), 'webfm_send/'.$file->id));
    $rows[] = array($href, format_size($file->s));
  }
  if (count($rows)) {
    return theme('table', $header, $rows, array('id' => 'attachments'));
  }
}

/**
 * Implementation of hook_form_alter().
 */
function webfm_attachment_form_alter($form_id, &$form) {
  global $base_url;

  if (isset($form['type'])) {
    if ($form['type']['#value'] .'_node_settings' == $form_id) {
      $form['workflow']['wfm_attach_'. $form['type']['#value']] = array(
        '#type' => 'radios', '#title' => t('Webfm Attachments'), '#default_value' => variable_get('wfm_attach_'. $form['type']['#value'], 1),
        '#options' => array(t('Disabled'), t('Enabled')),
      );
    }

    $node = $form['#node'];
    if (user_access('attach WebFM files') && $form['type']['#value'] .'_node_form' == $form_id && variable_get("wfm_attach_$node->type", TRUE)) {

      $modulepath = drupal_get_path('module', 'webfm');
      drupal_add_js($modulepath.'/js/webfm.js');
      drupal_add_js($modulepath.'/js/webfm_upload.js');
      drupal_add_js('misc/progress.js');
      theme_add_style($modulepath.'/css/webfm.css');
      if(is_null($inline_js))
        $inline_js = webfm_attachment_inline_js($base_url);

      // Attachments fieldset
      $form['#theme'] = 'webfm_attachment_upload_form';
      $form['attachments']['attached'] = array(
        '#type' => 'fieldset',
        '#title' => t('Attached files'),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
        '#weight' => 29,
      );
      $form['attachments']['attached']['attachedfiles'] = array(
        '#prefix' => '<div id="webfm-attach">',
        '#suffix' => '</div>',
      );
      $form['attachments']['attached']['attachedfiles'] += webfm_attach_attached_form($node);

      $form['browser']['browser'] = array(
        '#type' => 'fieldset',
        '#title' => t('File Browser'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#weight' => 30);
      // Wrapper for fieldset contents (used by upload JS).
      $form['browser']['browser']['wrapper'] = array(
        '#type' => 'fieldset',
        '#title' => t('File Upload'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#description' => t('Uploaded file will be saved to the current directory.'),
        '#prefix' => '<div id="webfm-inline">',
        '#suffix' => '</div>');
      $form['browser']['browser']['wrapper']['wrapper'] = array(
        '#prefix' => '<div id="attach-wrapper">',
        '#suffix' => '</div>');
      $form['browser']['browser']['wrapper']['wrapper'] +=  webfm_attachment_upload_form();
      $form['#attributes']['enctype'] = 'multipart/form-data';
    }
  }
}

function webfm_attach_attached_form($node) {
  $form['#theme'] = 'webfm_attach_attached_form';

  // This form input (id = edit-attachlist) will hold the comma-separated ordered list of attached fids
  $form['new']['attachlist']  = array(
    '#type' => 'hidden',
    '#value' => '');

  return $form;
}

/**
 * Theme the attachment form.
 * Note: required to output prefix/suffix.
 */
function theme_webfm_attach_attached_form($form) {
  $output = form_render($form);
  return $output;
}

function webfm_attachment_upload_form() {
  $form['#theme'] = 'webfm_attachment_upload_form';

  // This div is hidden when the user uploads through JS.
  $form['new'] = array(
    '#prefix' => '<div id="attach-hide">',
    '#suffix' => '</div>');

  $form['new']['upload'] = array(
    '#type' => 'file',
    '#title' => t('Upload file'),
    '#size' => 40);

  $form['new']['attach'] = array(
    '#type' => 'button',
    '#value' => t('Upload'),
    '#name'=> 'attach',
    '#attributes' => array('id' => 'attach'));

  // Hidden input field for js to supply current directory value
  $form['webfmuploadpath'] = array(
    '#type' => 'hidden',
    '#value' => '');

  // The class triggers the js upload behaviour.
  $form['attach'] = array(
    '#type' => 'hidden',
    '#value' => url('webfm_attach/upload', NULL, NULL, TRUE),
    '#attributes' => array('class' => 'webfmupload'));
  return $form;
}

/**
 * Theme the attachment form.
 * Note: required to output prefix/suffix.
 */
function theme_webfm_attachment_upload_form($form) {
  $output = form_render($form);
  return $output;
}

/**
 * Inline javascript
 * Function to pass url for browser AJAX XMLHttpRequests
 * Function to pass icon directory
 * Function to pass debug flag to enable client side debug output
 */
function webfm_attachment_inline_js($base_url) {
  $js = '<script type="text/javascript">
           function getBaseUrl() { return '.drupal_to_js($base_url).'; }
           function getBrowserUrl() { return '.drupal_to_js($base_url."/admin/webfm").'; }
           function getAttachUrl() { return '.drupal_to_js($base_url."/webfm_attachment").'; }
           function getIconDir() { return '.drupal_to_js($base_url."/".variable_get('webfm_icon_dir', '')).'; }
           function getDebugFlag() { return '.drupal_to_js(variable_get('webfm_debug', '')).'; }
         </script>';
  drupal_set_html_head($js);
  return $js;
}

/**
 * webfm_dbupdate_attach - updates the files in the webfm_attach table IF the order
 *
 * @param int $nid
 * @param array $fids - could be a comma seperated string - we need to work that out - works both ways now
 * @return TRUE if records were updated - NULL if no changes were required.
 */

function webfm_dbupdate_attach($nid, $fids){
//  drupal_set_message(t('fidcount= %fid', array('%fid' => count($fids))));
  $i = 0;
  if(!webfm_check_attach_order($nid, $fids)){ //the new fids are different from the old ones
    $query = "DELETE FROM {webfm_attach} where nid = %d";
    if($result = db_query($query, $nid)){
      foreach($fids as $fid){
        drupal_set_message(t('fid= %fid', array('%fid' => $fid)));
        if($fid)
          webfm_dbinsert_attach($nid, $fid, $i++);
        $flag = TRUE;
      }
      if($flag === TRUE) return TRUE;
    }
  }
}

/**
 * webfm_checkattachorder - checks to see if the new order of the fids is the same as the old order stored in the database
 *
 * @param int $nid - node id
 * @param array $fids - array of file ids
 * @return bool - TRUE if the attach order is the same - FALSE if it has changed
 */
function webfm_check_attach_order($nid, $fids){
  //check array against db result
  $query = "SELECT fid FROM {webfm_attach} WHERE nid = %d ORDER BY weight";
  $result = db_query($query, $nid);

  if($dbfids = db_fetch_array($result)){
    if(count($dbfids) <= count($fids)){
      return false;
    }
    for($i == 0; $i<=count($fids); $i++){
      if($dbfids[$i] == $fids[$i]){
        $match = TRUE;
      } else {
        return FALSE;
      }
    }
  }

  if($match)
    return TRUE;
}

/**
 * webfm_dbinsert_attach - inserts nid, fid and weight to webfm_attach table (similar to files table)
 *
 * @param int $nid - node id
 * @param int $fid - file id from the webfm_file table
 * @param int $weight - weight value
 *
 * @return bool - TRUE if success - else FALSE
 */

function webfm_dbinsert_attach($nid, $fid, $weight){
//  drupal_set_message('DBG: SELECT * FROM {webfm_attach} WHERE nid = '. $nid .' and fid = '.$fid);
  $query = 'SELECT * FROM {webfm_attach} WHERE nid = %d and fid = %d';
  $result = db_query($query, $nid, $fid);
  if(!mysql_num_rows($result) == 0) {
   drupal_set_message(t('File is already attached to this node.'));
   return FALSE;
  } else {
    //actually do the attacment if its not already attached....
    $query = 'INSERT INTO {webfm_attach} (nid, fid, weight) values (%d, %d, %s)';
    $result = db_query($query, $nid, $fid, $weight);

    if($result === FALSE) {
      drupal_set_message(t('Query Failed:  Could not attach files to node ') . $nid);
      return FALSE;
    } else {
      return TRUE;
    }
  }
}

/**
 * webfm_dbdelete_attach - deletes node file associations given a nid and fid
 *
 * @param int $nid - node id
 * @param int $fid - file id from the webfm_file table
 * @return bool - TRUE if success - else FALSE
 *
 */
function webfm_dbdelete_attach($nid, $fid){
  $query = 'DELETE FROM {webfm_attach} WHERE nid = %d and fid = %d';
  $result = db_query($query, $nid, $fid);
  if($result === FALSE) {
    drupal_set_message(t('Query Failed: Could not detach file %fid from node %nid', array('%fid' => $fid, '%nid'=>$nid)));
    return FALSE;
  }
  return TRUE;
}

/**
 * Helper function that deletes db entries from the webfm_attach table given fid
 * called from webfm_dbdelete_file
 *
 * @param int $fid
 * @return bool
 */
function _webfm_dbdelete_attach_fid($fid){
  $query = 'DELETE FROM {webfm_attach} WHERE fid = %d';
  $result = db_query($query, $fid);
  if($result === FALSE) {
    drupal_set_message(t('Query Failed: Could not detach file %fid from nodes.', array('%fid' => $fid)));
    return FALSE;
  }
  return TRUE;
}
